// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package vsphere

import (
	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// The `vsphere_virtual_machine` resource can be used to manage the complex
// lifecycle of a virtual machine. It supports management of disk, network
// interface, and CDROM devices, creation from scratch or cloning from template,
// and migration through both host and storage vMotion.
// 
// For more details on working with virtual machines in vSphere, see [this
// page][vmware-docs-vm-management].
// 
// [vmware-docs-vm-management]: https://docs.vmware.com/en/VMware-vSphere/6.5/com.vmware.vsphere.vm_admin.doc/GUID-55238059-912E-411F-A0E9-A7A536972A91.html
// 
// ## About Working with Virtual Machines in Terraform
// 
// A high degree of control and flexibility is afforded to a vSphere user when it
// comes to how to configure, deploy, and manage virtual machines - much more
// control than given in a traditional cloud provider. As such, Terraform has to
// make some decisions on how to manage the virtual machines it creates and
// manages. This section documents things you need to know about your virtual
// machine configuration that you should consider when setting up virtual
// machines, creating templates to clone from, or migrating from previous versions
// of this resource.
// 
// ### Disks
// 
// The `vsphere_virtual_machine` resource currently only supports standard
// VMDK-backed virtual disks - it does not support other special kinds of disk
// devices like RDM disks.
// 
// Disks are managed by an arbitrary label supplied to the `label`
// attribute of a `disk` block. This is separate from the
// automatic naming that vSphere picks for you when creating a virtual machine.
// Control over a virtual disk's name is not supported unless you are attaching an
// external disk with the `attach` attribute.
// 
// Virtual disks can be SCSI disks only. The SCSI controllers managed by Terraform
// can vary, depending on the value supplied to
// `scsi_controller_count`. This also dictates the
// controllers that are checked when looking for disks during a cloning process.
// By default, this value is `1`, meaning that you can have up to 15 disks
// configured on a virtual machine. These are all configured with the controller
// type defined by the `scsi_type` setting. If you are cloning from
// a template, devices will be added or re-configured as necessary.
// 
// When cloning from a template, you must specify disks of either the same or
// greater size than the disks in the source template when creating a traditional
// clone, or exactly the same size when cloning from snapshot (also known as a
// linked clone). For more details, see the section on creating a virtual machine
// from a template.
// 
// A maximum of 60 virtual disks can be configured when the
// `scsi_controller_count` setting is configured to its
// maximum of `4` controllers. See the disk options section for
// more details.
// 
// ### Customization and network waiters
// 
// Terraform waits during various parts of a virtual machine deployment to ensure
// that it is in a correct expected state before proceeding. These happen when a
// VM is created, or also when it's updated, depending on the waiter.
// 
// Two waiters of note are:
// 
// * **The customization waiter:** This waiter watches events in vSphere to
//   monitor when customization on a virtual machine completes during VM creation.
//   Depending on your vSphere or VM configuration it may be necessary to change
//   the timeout or turn it off. This can be controlled by the
//   `timeout` setting in the customization
//   settings block.
// * **The network waiter:** This waiter waits for interfaces to show up on a
//   guest virtual machine close to the end of both VM creation and update. This
//   waiter is necessary to ensure that correct IP information gets reported to
//   the guest virtual machine, mainly to facilitate the availability of a valid,
//   reachable default IP address for any [provisioners][tf-docs-provisioners].
//   The behavior of the waiter can be controlled with the
//   `wait_for_guest_net_timeout`,
//   `wait_for_guest_net_routable`,
//   `wait_for_guest_ip_timeout`, and
//   `ignored_guest_ips` settings.
// 
// [tf-docs-provisioners]: /docs/provisioners/index.html
// 
// ### Migrating from a previous version of this resource
// 
// > **NOTE:** This section only applies to versions of this resource available
// in versions v0.4.2 of this provider or earlier.
// 
// The path for migrating to the current version of this resource is very similar
// to the import path, with the exception that the `terraform
// import` command does not need to be run. See that section for details on what
// is required before you run `terraform plan` on a state that requires migration.
// 
// A successful migration usually only results in a configuration-only diff - that
// is, Terraform reconciles some configuration settings that cannot be set during
// the migration process with state. In this event, no reconfiguration operations
// are sent to the vSphere server during the next `terraform apply`.  See the
// importing section for more details.
// 
// ## Creating a Virtual Machine from a Template
// 
// The `clone` block can be used to create a new virtual machine from an existing
// virtual machine or template. The resource supports both making a complete copy
// of a virtual machine, or cloning from a snapshot (otherwise known as a linked
// clone).
// 
// See the cloning and customization
// example for a usage synopsis.
// 
// > **NOTE:** Changing any option in `clone` after creation forces a new
// resource.
// 
// > **NOTE:** Cloning requires vCenter and is not supported on direct ESXi
// connections.
// 
// The options available in the `clone` block are:
// 
// * `template_uuid` - (Required) The UUID of the source virtual machine or
//   template.
// * `linked_clone` - (Optional) Clone this virtual machine from a snapshot.
//   Templates must have a single snapshot only in order to be eligible. Default:
//   `false`.
// * `timeout` - (Optional) The timeout, in minutes, to wait for the virtual
//   machine clone to complete. Default: 30 minutes.
// * `customize` - (Optional) The customization spec for this clone. This allows
//   the user to configure the virtual machine post-clone. For more details, see
//   virtual machine customization.
// 
// ### Additional requirements and notes for cloning
// 
// Note that when cloning from a template, there are additional requirements in
// both the resource configuration and source template:
// 
// * The virtual machine must not be powered on at the time of cloning.
// * All disks on the virtual machine must be SCSI disks.
// * You must specify at least the same number of `disk` devices as there are
//   disks that exist in the template. These devices are ordered and lined up by
//   the `unit_number` attribute. Additional disks can be added past this.
// * The `size` of a virtual disk must be at least the same size as its
//   counterpart disk in the template.
// * When using `linked_clone`, the `size`, `thin_provisioned`, and
//   `eagerly_scrub` settings for each disk must be an exact match to the
//   individual disk's counterpart in the source template.
// * The `scsi_controller_count` setting should be
//   configured as necessary to cover all of the disks on the template. For best
//   results, only configure this setting for the amount of controllers you will
//   need to cover your disk quantity and bandwidth needs, and configure your
//   template accordingly. For most workloads, this setting should be kept at its
//   default of `1`, and all disks in the template should reside on the single,
//   primary controller.
// * Some operating systems (such as Windows) do not respond well to a change in
//   disk controller type, so when using such OSes, take care to ensure that
//   `scsi_type` is set to an exact match of the template's controller set. For
//   maximum compatibility, make sure the SCSI controllers on the source template
//   are all the same type.
// 
// To ease the gathering of some of these options, you can use the
// [`vsphere_virtual_machine` data source][tf-vsphere-virtual-machine-ds], which
// will give you disk attributes, network interface types, SCSI bus types, and
// also the guest ID of the source template.  See the cloning and customization
// example for usage details.
// 
// ## Virtual Machine Migration
// 
// The `vsphere_virtual_machine` resource supports live migration (otherwise known
// as vMotion) both on the host and storage level. One can migrate the entire VM
// to another host, cluster, resource pool, or datastore, and migrate or pin a
// single disk to a specific datastore.
// 
// ### Host, cluster, and resource pool migration 
// 
// To migrate the virtual machine to another host or resource pool, change the
// `host_system_id` or `resource_pool_id` to the manged object IDs of the new host
// or resource pool accordingly. To change the virtual machine's cluster or
// standalone host, select a resource pool within the specific target.
// 
// The same rules apply for migration as they do for VM creation - any host
// specified needs to be a part of the resource pool supplied. Also keep in mind
// the implications of moving the virtual machine to a resource pool in another
// cluster or standalone host, namely ensuring that all hosts in the cluster (or
// the single standalone host) have access to the datastore that the virtual
// machine is in.
// 
// ## Importing 
// 
// ### Additional requirements and notes for importing
// 
// Many of the same requirements for
// cloning apply to importing,
// although since importing writes directly to state, a lot of these rules cannot
// be enforced at import time, so every effort should be made to ensure the
// correctness of the configuration before the import.
// 
// In addition to these rules, the following extra rules apply to importing:
// 
// * Disks need to have their `label` argument assigned in a convention
//   matching `diskN`, starting with disk number 0, based on each disk's order on
//   the SCSI bus. As an example, a disk on SCSI controller 0 with a unit number
//   of 0 would be labeled `disk0`, a disk on the same controller with a unit
//   number of 1 would be `disk1`, but the next disk, which is on SCSI controller
//   1 with a unit number of 0, still becomes `disk2`.
// * Disks always get imported with `keep_on_remove` enabled
//   until the first `terraform apply` runs, which will remove the setting for
//   known disks. This is an extra safeguard against naming or accounting mistakes
//   in the disk configuration.
// * The `scsi_controller_count` for the resource is set
//   to the number of contiguous SCSI controllers found, starting with the SCSI
//   controller at bus number 0. If no SCSI controllers are found, the VM is not
//   eligible for import. To ensure maximum compatibility, make sure your virtual
//   machine has the exact number of SCSI controllers it needs, and set
//   `scsi_controller_count` accordingly.
// 
// After importing, you should run `terraform plan`. Unless you have changed
// anything else in configuration that would be causing other attributes to
// change, the only difference should be configuration-only changes, usually
// comprising of:
// 
// * The `imported` flag will transition from `true` to `false`.
// * `keep_on_remove` of known disks will transition from
//   `true` to `false`. 
// * Configuration supplied in the `clone` block, if present, will be
//   persisted to state. This initial persistence operation does not perform any
//   cloning or customization actions, nor does it force a new resource. After the
//   first apply operation, further changes to `clone` will force a new resource
//   as per normal operation.
// 
// > **NOTE:** Further to the above, do not make any configuration changes to
// `clone` after importing or upgrading from a legacy version of the provider
// before doing an initial `terraform apply` as these changes will not correctly
// force a new resource, and your changes will have persisted to state, preventing
// further plans from correctly triggering a diff.
// 
// These changes only update Terraform state when applied, hence it is safe to run
// when the virtual machine is running. If more settings are being modified, you
// may need to plan maintenance accordingly for any necessary re-configuration of
// the virtual machine.
type VirtualMachine struct {
	s *pulumi.ResourceState
}

// NewVirtualMachine registers a new resource with the given unique name, arguments, and options.
func NewVirtualMachine(ctx *pulumi.Context,
	name string, args *VirtualMachineArgs, opts ...pulumi.ResourceOpt) (*VirtualMachine, error) {
	if args == nil || args.NetworkInterfaces == nil {
		return nil, errors.New("missing required argument 'NetworkInterfaces'")
	}
	if args == nil || args.ResourcePoolId == nil {
		return nil, errors.New("missing required argument 'ResourcePoolId'")
	}
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["alternateGuestName"] = nil
		inputs["annotation"] = nil
		inputs["bootDelay"] = nil
		inputs["bootRetryDelay"] = nil
		inputs["bootRetryEnabled"] = nil
		inputs["cdrom"] = nil
		inputs["clone"] = nil
		inputs["cpuHotAddEnabled"] = nil
		inputs["cpuHotRemoveEnabled"] = nil
		inputs["cpuLimit"] = nil
		inputs["cpuPerformanceCountersEnabled"] = nil
		inputs["cpuReservation"] = nil
		inputs["cpuShareCount"] = nil
		inputs["cpuShareLevel"] = nil
		inputs["customAttributes"] = nil
		inputs["datastoreClusterId"] = nil
		inputs["datastoreId"] = nil
		inputs["disks"] = nil
		inputs["efiSecureBootEnabled"] = nil
		inputs["enableDiskUuid"] = nil
		inputs["enableLogging"] = nil
		inputs["eptRviMode"] = nil
		inputs["extraConfig"] = nil
		inputs["firmware"] = nil
		inputs["folder"] = nil
		inputs["forcePowerOff"] = nil
		inputs["guestId"] = nil
		inputs["hostSystemId"] = nil
		inputs["hvMode"] = nil
		inputs["ignoredGuestIps"] = nil
		inputs["latencySensitivity"] = nil
		inputs["memory"] = nil
		inputs["memoryHotAddEnabled"] = nil
		inputs["memoryLimit"] = nil
		inputs["memoryReservation"] = nil
		inputs["memoryShareCount"] = nil
		inputs["memoryShareLevel"] = nil
		inputs["migrateWaitTimeout"] = nil
		inputs["name"] = nil
		inputs["nestedHvEnabled"] = nil
		inputs["networkInterfaces"] = nil
		inputs["numCoresPerSocket"] = nil
		inputs["numCpus"] = nil
		inputs["resourcePoolId"] = nil
		inputs["runToolsScriptsAfterPowerOn"] = nil
		inputs["runToolsScriptsAfterResume"] = nil
		inputs["runToolsScriptsBeforeGuestReboot"] = nil
		inputs["runToolsScriptsBeforeGuestShutdown"] = nil
		inputs["runToolsScriptsBeforeGuestStandby"] = nil
		inputs["scsiBusSharing"] = nil
		inputs["scsiControllerCount"] = nil
		inputs["scsiType"] = nil
		inputs["shutdownWaitTimeout"] = nil
		inputs["swapPlacementPolicy"] = nil
		inputs["syncTimeWithHost"] = nil
		inputs["tags"] = nil
		inputs["vapp"] = nil
		inputs["waitForGuestIpTimeout"] = nil
		inputs["waitForGuestNetRoutable"] = nil
		inputs["waitForGuestNetTimeout"] = nil
	} else {
		inputs["alternateGuestName"] = args.AlternateGuestName
		inputs["annotation"] = args.Annotation
		inputs["bootDelay"] = args.BootDelay
		inputs["bootRetryDelay"] = args.BootRetryDelay
		inputs["bootRetryEnabled"] = args.BootRetryEnabled
		inputs["cdrom"] = args.Cdrom
		inputs["clone"] = args.Clone
		inputs["cpuHotAddEnabled"] = args.CpuHotAddEnabled
		inputs["cpuHotRemoveEnabled"] = args.CpuHotRemoveEnabled
		inputs["cpuLimit"] = args.CpuLimit
		inputs["cpuPerformanceCountersEnabled"] = args.CpuPerformanceCountersEnabled
		inputs["cpuReservation"] = args.CpuReservation
		inputs["cpuShareCount"] = args.CpuShareCount
		inputs["cpuShareLevel"] = args.CpuShareLevel
		inputs["customAttributes"] = args.CustomAttributes
		inputs["datastoreClusterId"] = args.DatastoreClusterId
		inputs["datastoreId"] = args.DatastoreId
		inputs["disks"] = args.Disks
		inputs["efiSecureBootEnabled"] = args.EfiSecureBootEnabled
		inputs["enableDiskUuid"] = args.EnableDiskUuid
		inputs["enableLogging"] = args.EnableLogging
		inputs["eptRviMode"] = args.EptRviMode
		inputs["extraConfig"] = args.ExtraConfig
		inputs["firmware"] = args.Firmware
		inputs["folder"] = args.Folder
		inputs["forcePowerOff"] = args.ForcePowerOff
		inputs["guestId"] = args.GuestId
		inputs["hostSystemId"] = args.HostSystemId
		inputs["hvMode"] = args.HvMode
		inputs["ignoredGuestIps"] = args.IgnoredGuestIps
		inputs["latencySensitivity"] = args.LatencySensitivity
		inputs["memory"] = args.Memory
		inputs["memoryHotAddEnabled"] = args.MemoryHotAddEnabled
		inputs["memoryLimit"] = args.MemoryLimit
		inputs["memoryReservation"] = args.MemoryReservation
		inputs["memoryShareCount"] = args.MemoryShareCount
		inputs["memoryShareLevel"] = args.MemoryShareLevel
		inputs["migrateWaitTimeout"] = args.MigrateWaitTimeout
		inputs["name"] = args.Name
		inputs["nestedHvEnabled"] = args.NestedHvEnabled
		inputs["networkInterfaces"] = args.NetworkInterfaces
		inputs["numCoresPerSocket"] = args.NumCoresPerSocket
		inputs["numCpus"] = args.NumCpus
		inputs["resourcePoolId"] = args.ResourcePoolId
		inputs["runToolsScriptsAfterPowerOn"] = args.RunToolsScriptsAfterPowerOn
		inputs["runToolsScriptsAfterResume"] = args.RunToolsScriptsAfterResume
		inputs["runToolsScriptsBeforeGuestReboot"] = args.RunToolsScriptsBeforeGuestReboot
		inputs["runToolsScriptsBeforeGuestShutdown"] = args.RunToolsScriptsBeforeGuestShutdown
		inputs["runToolsScriptsBeforeGuestStandby"] = args.RunToolsScriptsBeforeGuestStandby
		inputs["scsiBusSharing"] = args.ScsiBusSharing
		inputs["scsiControllerCount"] = args.ScsiControllerCount
		inputs["scsiType"] = args.ScsiType
		inputs["shutdownWaitTimeout"] = args.ShutdownWaitTimeout
		inputs["swapPlacementPolicy"] = args.SwapPlacementPolicy
		inputs["syncTimeWithHost"] = args.SyncTimeWithHost
		inputs["tags"] = args.Tags
		inputs["vapp"] = args.Vapp
		inputs["waitForGuestIpTimeout"] = args.WaitForGuestIpTimeout
		inputs["waitForGuestNetRoutable"] = args.WaitForGuestNetRoutable
		inputs["waitForGuestNetTimeout"] = args.WaitForGuestNetTimeout
	}
	inputs["changeVersion"] = nil
	inputs["defaultIpAddress"] = nil
	inputs["guestIpAddresses"] = nil
	inputs["imported"] = nil
	inputs["moid"] = nil
	inputs["rebootRequired"] = nil
	inputs["uuid"] = nil
	inputs["vappTransports"] = nil
	inputs["vmwareToolsStatus"] = nil
	inputs["vmxPath"] = nil
	s, err := ctx.RegisterResource("vsphere:index/virtualMachine:VirtualMachine", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &VirtualMachine{s: s}, nil
}

// GetVirtualMachine gets an existing VirtualMachine resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetVirtualMachine(ctx *pulumi.Context,
	name string, id pulumi.ID, state *VirtualMachineState, opts ...pulumi.ResourceOpt) (*VirtualMachine, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["alternateGuestName"] = state.AlternateGuestName
		inputs["annotation"] = state.Annotation
		inputs["bootDelay"] = state.BootDelay
		inputs["bootRetryDelay"] = state.BootRetryDelay
		inputs["bootRetryEnabled"] = state.BootRetryEnabled
		inputs["cdrom"] = state.Cdrom
		inputs["changeVersion"] = state.ChangeVersion
		inputs["clone"] = state.Clone
		inputs["cpuHotAddEnabled"] = state.CpuHotAddEnabled
		inputs["cpuHotRemoveEnabled"] = state.CpuHotRemoveEnabled
		inputs["cpuLimit"] = state.CpuLimit
		inputs["cpuPerformanceCountersEnabled"] = state.CpuPerformanceCountersEnabled
		inputs["cpuReservation"] = state.CpuReservation
		inputs["cpuShareCount"] = state.CpuShareCount
		inputs["cpuShareLevel"] = state.CpuShareLevel
		inputs["customAttributes"] = state.CustomAttributes
		inputs["datastoreClusterId"] = state.DatastoreClusterId
		inputs["datastoreId"] = state.DatastoreId
		inputs["defaultIpAddress"] = state.DefaultIpAddress
		inputs["disks"] = state.Disks
		inputs["efiSecureBootEnabled"] = state.EfiSecureBootEnabled
		inputs["enableDiskUuid"] = state.EnableDiskUuid
		inputs["enableLogging"] = state.EnableLogging
		inputs["eptRviMode"] = state.EptRviMode
		inputs["extraConfig"] = state.ExtraConfig
		inputs["firmware"] = state.Firmware
		inputs["folder"] = state.Folder
		inputs["forcePowerOff"] = state.ForcePowerOff
		inputs["guestId"] = state.GuestId
		inputs["guestIpAddresses"] = state.GuestIpAddresses
		inputs["hostSystemId"] = state.HostSystemId
		inputs["hvMode"] = state.HvMode
		inputs["ignoredGuestIps"] = state.IgnoredGuestIps
		inputs["imported"] = state.Imported
		inputs["latencySensitivity"] = state.LatencySensitivity
		inputs["memory"] = state.Memory
		inputs["memoryHotAddEnabled"] = state.MemoryHotAddEnabled
		inputs["memoryLimit"] = state.MemoryLimit
		inputs["memoryReservation"] = state.MemoryReservation
		inputs["memoryShareCount"] = state.MemoryShareCount
		inputs["memoryShareLevel"] = state.MemoryShareLevel
		inputs["migrateWaitTimeout"] = state.MigrateWaitTimeout
		inputs["moid"] = state.Moid
		inputs["name"] = state.Name
		inputs["nestedHvEnabled"] = state.NestedHvEnabled
		inputs["networkInterfaces"] = state.NetworkInterfaces
		inputs["numCoresPerSocket"] = state.NumCoresPerSocket
		inputs["numCpus"] = state.NumCpus
		inputs["rebootRequired"] = state.RebootRequired
		inputs["resourcePoolId"] = state.ResourcePoolId
		inputs["runToolsScriptsAfterPowerOn"] = state.RunToolsScriptsAfterPowerOn
		inputs["runToolsScriptsAfterResume"] = state.RunToolsScriptsAfterResume
		inputs["runToolsScriptsBeforeGuestReboot"] = state.RunToolsScriptsBeforeGuestReboot
		inputs["runToolsScriptsBeforeGuestShutdown"] = state.RunToolsScriptsBeforeGuestShutdown
		inputs["runToolsScriptsBeforeGuestStandby"] = state.RunToolsScriptsBeforeGuestStandby
		inputs["scsiBusSharing"] = state.ScsiBusSharing
		inputs["scsiControllerCount"] = state.ScsiControllerCount
		inputs["scsiType"] = state.ScsiType
		inputs["shutdownWaitTimeout"] = state.ShutdownWaitTimeout
		inputs["swapPlacementPolicy"] = state.SwapPlacementPolicy
		inputs["syncTimeWithHost"] = state.SyncTimeWithHost
		inputs["tags"] = state.Tags
		inputs["uuid"] = state.Uuid
		inputs["vapp"] = state.Vapp
		inputs["vappTransports"] = state.VappTransports
		inputs["vmwareToolsStatus"] = state.VmwareToolsStatus
		inputs["vmxPath"] = state.VmxPath
		inputs["waitForGuestIpTimeout"] = state.WaitForGuestIpTimeout
		inputs["waitForGuestNetRoutable"] = state.WaitForGuestNetRoutable
		inputs["waitForGuestNetTimeout"] = state.WaitForGuestNetTimeout
	}
	s, err := ctx.ReadResource("vsphere:index/virtualMachine:VirtualMachine", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &VirtualMachine{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *VirtualMachine) URN() *pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *VirtualMachine) ID() *pulumi.IDOutput {
	return r.s.ID()
}

// The guest name for the operating system
// when `guest_id` is `other` or `other-64`.
func (r *VirtualMachine) AlternateGuestName() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["alternateGuestName"])
}

// A user-provided description of the virtual machine.
// The default is no annotation.
func (r *VirtualMachine) Annotation() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["annotation"])
}

// The number of milliseconds to wait before starting
// the boot sequence. The default is no delay.
func (r *VirtualMachine) BootDelay() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["bootDelay"])
}

// The number of milliseconds to wait before
// retrying the boot sequence. This only valid if `boot_retry_enabled` is true.
// Default: `10000` (10 seconds).
func (r *VirtualMachine) BootRetryDelay() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["bootRetryDelay"])
}

// If set to true, a virtual machine that
// fails to boot will try again after the delay defined in `boot_retry_delay`.
// Default: `false`.
func (r *VirtualMachine) BootRetryEnabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["bootRetryEnabled"])
}

// A specification for a CDROM device on this virtual
// machine. See CDROM options below.
func (r *VirtualMachine) Cdrom() *pulumi.Output {
	return r.s.State["cdrom"]
}

// A unique identifier for a given version of the last
// configuration applied, such the timestamp of the last update to the
// configuration.
func (r *VirtualMachine) ChangeVersion() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["changeVersion"])
}

// When specified, the VM will be created as a clone of a
// specified template. Optional customization options can be submitted as well.
// See creating a virtual machine from a
// template for more details.
func (r *VirtualMachine) Clone() *pulumi.Output {
	return r.s.State["clone"]
}

// Allow CPUs to be added to this virtual
// machine while it is running.
func (r *VirtualMachine) CpuHotAddEnabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["cpuHotAddEnabled"])
}

// Allow CPUs to be removed to this
// virtual machine while it is running.
func (r *VirtualMachine) CpuHotRemoveEnabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["cpuHotRemoveEnabled"])
}

// The maximum amount of CPU (in MHz) that this virtual
// machine can consume, regardless of available resources. The default is no
// limit.
func (r *VirtualMachine) CpuLimit() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["cpuLimit"])
}

// Enable CPU performance
// counters on this virtual machine. Default: `false`.
func (r *VirtualMachine) CpuPerformanceCountersEnabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["cpuPerformanceCountersEnabled"])
}

// The amount of CPU (in MHz) that this virtual
// machine is guaranteed. The default is no reservation.
func (r *VirtualMachine) CpuReservation() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["cpuReservation"])
}

// The number of CPU shares allocated to the
// virtual machine when the `cpu_share_level` is `custom`.
func (r *VirtualMachine) CpuShareCount() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["cpuShareCount"])
}

// The allocation level for CPU resources. Can be
// one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
func (r *VirtualMachine) CpuShareLevel() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["cpuShareLevel"])
}

// Map of custom attribute ids to attribute
// value strings to set for virtual machine. See
// [here][docs-setting-custom-attributes] for a reference on how to set values
// for custom attributes.
func (r *VirtualMachine) CustomAttributes() *pulumi.MapOutput {
	return (*pulumi.MapOutput)(r.s.State["customAttributes"])
}

// The [managed object reference
// ID][docs-about-morefs] of the datastore cluster ID to use. This setting
// applies to entire virtual machine and implies that you wish to use Storage
// DRS with this virtual machine. See the section on virtual machine
// migration for details on changing this value.
func (r *VirtualMachine) DatastoreClusterId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["datastoreClusterId"])
}

// The datastore ID that the ISO is located in.
// Requried for using a datastore ISO. Conflicts with `client_device`.
func (r *VirtualMachine) DatastoreId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["datastoreId"])
}

// The IP address selected by Terraform to be used with
// any [provisioners][tf-docs-provisioners] configured on this resource.
// Whenever possible, this is the first IPv4 address that is reachable through
// the default gateway configured on the machine, then the first reachable IPv6
// address, and then the first general discovered address if neither exist. If
// VMware tools is not running on the virtual machine, or if the VM is powered
// off, this value will be blank.
func (r *VirtualMachine) DefaultIpAddress() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["defaultIpAddress"])
}

// A specification for a virtual disk device on this virtual
// machine. See disk options below.
func (r *VirtualMachine) Disks() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["disks"])
}

// When the `firmware` type is set to is
// `efi`, this enables EFI secure boot. Default: `false`.
func (r *VirtualMachine) EfiSecureBootEnabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["efiSecureBootEnabled"])
}

// Expose the UUIDs of attached virtual disks to
// the virtual machine, allowing access to them in the guest. Default: `false`.
func (r *VirtualMachine) EnableDiskUuid() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["enableDiskUuid"])
}

// Enable logging of virtual machine events to a
// log file stored in the virtual machine directory. Default: `false`.
func (r *VirtualMachine) EnableLogging() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["enableLogging"])
}

// The EPT/RVI (hardware memory virtualization)
// setting for this virtual machine. Can be one of `automatic`, `on`, or `off`.
// Default: `automatic`.
func (r *VirtualMachine) EptRviMode() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["eptRviMode"])
}

// Extra configuration data for this virtual
// machine. Can be used to supply advanced parameters not normally in
// configuration, such as data for cloud-config (under the guestinfo namespace).
func (r *VirtualMachine) ExtraConfig() *pulumi.MapOutput {
	return (*pulumi.MapOutput)(r.s.State["extraConfig"])
}

// The firmware interface to use on the virtual machine.
// Can be one of `bios` or `EFI`. Default: `bios`.
func (r *VirtualMachine) Firmware() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["firmware"])
}

// The path to the folder to put this virtual machine in,
// relative to the datacenter that the resource pool is in.
func (r *VirtualMachine) Folder() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["folder"])
}

// If a guest shutdown failed or timed out while
// updating or destroying (see
// `shutdown_wait_timeout`), force the power-off of
// the virtual machine. Default: `true`.
func (r *VirtualMachine) ForcePowerOff() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["forcePowerOff"])
}

// The guest ID for the operating system type. For a
// full list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.
func (r *VirtualMachine) GuestId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["guestId"])
}

// The current list of IP addresses on this machine,
// including the value of `default_ip_address`. If VMware tools is not running
// on the virtual machine, or if the VM is powered off, this list will be empty.
// * `moid`: The [managed object reference ID][docs-about-morefs] of the created
// virtual machine.
func (r *VirtualMachine) GuestIpAddresses() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["guestIpAddresses"])
}

// An optional [managed object reference
// ID][docs-about-morefs] of a host to put this virtual machine on. See the
// section on virtual machine migration for
// details on changing this value. If a `host_system_id` is not supplied,
// vSphere will select a host in the resource pool to place the virtual machine,
// according to any defaults or DRS policies in place.
func (r *VirtualMachine) HostSystemId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["hostSystemId"])
}

// The (non-nested) hardware virtualization setting for
// this virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:
// `hvAuto`.
func (r *VirtualMachine) HvMode() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["hvMode"])
}

// List of IP addresses to ignore while waiting
// for an available IP address using either of the waiters. Any IP addresses in
// this list will be ignored if they show up so that the waiter will continue to
// wait for a real IP address. Default: [].
func (r *VirtualMachine) IgnoredGuestIps() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["ignoredGuestIps"])
}

// This is flagged if the virtual machine has been imported, or the
// state has been migrated from a previous version of the resource. It
// influences the behavior of the first post-import apply operation. See the
// section on importing below.
func (r *VirtualMachine) Imported() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["imported"])
}

// Controls the scheduling delay of the
// virtual machine. Use a higher sensitivity for applications that require lower
// latency, such as VOIP, media player applications, or applications that
// require frequent access to mouse or keyboard devices. Can be one of `low`,
// `normal`, `medium`, or `high`.
func (r *VirtualMachine) LatencySensitivity() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["latencySensitivity"])
}

// The size of the virtual machine's memory, in MB.
// Default: `1024` (1 GB).
func (r *VirtualMachine) Memory() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["memory"])
}

// Allow memory to be added to this
// virtual machine while it is running.
func (r *VirtualMachine) MemoryHotAddEnabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["memoryHotAddEnabled"])
}

// The maximum amount of memory (in MB) that this
// virtual machine can consume, regardless of available resources. The default
// is no limit.
func (r *VirtualMachine) MemoryLimit() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["memoryLimit"])
}

// The amount of memory (in MB) that this
// virtual machine is guaranteed. The default is no reservation.
func (r *VirtualMachine) MemoryReservation() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["memoryReservation"])
}

// The number of memory shares allocated to
// the virtual machine when the `memory_share_level` is `custom`.
func (r *VirtualMachine) MemoryShareCount() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["memoryShareCount"])
}

// The allocation level for memory resources.
// Can be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
func (r *VirtualMachine) MemoryShareLevel() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["memoryShareLevel"])
}

// The amount of time, in minutes, to wait
// for a virtual machine migration to complete before failing. Default: 10
// minutes. Also see the section on virtual machine
// migration.
func (r *VirtualMachine) MigrateWaitTimeout() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["migrateWaitTimeout"])
}

// The machine object ID from VMWare
func (r *VirtualMachine) Moid() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["moid"])
}

// An alias for both `label` and `path`, the latter when
// using `attach`. Required if not using `label`.
func (r *VirtualMachine) Name() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["name"])
}

// Enable nested hardware virtualization on
// this virtual machine, facilitating nested virtualization in the guest.
// Default: `false`.
func (r *VirtualMachine) NestedHvEnabled() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["nestedHvEnabled"])
}

// A specification for a virtual NIC on this
// virtual machine. See network interface options
// below.
func (r *VirtualMachine) NetworkInterfaces() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["networkInterfaces"])
}

// The number of cores to distribute among
// the CPUs in this virtual machine. If specified, the value supplied to
// `num_cpus` must be evenly divisible by this value. Default: `1`.
func (r *VirtualMachine) NumCoresPerSocket() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["numCoresPerSocket"])
}

// The number of virtual processors to assign to this
// virtual machine. Default: `1`.
func (r *VirtualMachine) NumCpus() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["numCpus"])
}

// Value internal to Terraform used to determine if a
// configuration set change requires a reboot. This value is only useful during
// an update process and gets reset on refresh.
func (r *VirtualMachine) RebootRequired() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["rebootRequired"])
}

// The [managed object reference
// ID][docs-about-morefs] of the resource pool to put this virtual machine in.
// See the section on virtual machine migration
// for details on changing this value.
func (r *VirtualMachine) ResourcePoolId() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["resourcePoolId"])
}

// Enable the execution of
// post-power-on scripts when VMware tools is installed. Default: `true`.
func (r *VirtualMachine) RunToolsScriptsAfterPowerOn() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["runToolsScriptsAfterPowerOn"])
}

// Enable the execution of
// post-resume scripts when VMware tools is installed. Default: `true`.
func (r *VirtualMachine) RunToolsScriptsAfterResume() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["runToolsScriptsAfterResume"])
}

// Enable the execution of
// pre-reboot scripts when VMware tools is installed. Default: `false`.
func (r *VirtualMachine) RunToolsScriptsBeforeGuestReboot() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["runToolsScriptsBeforeGuestReboot"])
}

// Enable the execution
// of pre-shutdown scripts when VMware tools is installed. Default: `true`.
func (r *VirtualMachine) RunToolsScriptsBeforeGuestShutdown() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["runToolsScriptsBeforeGuestShutdown"])
}

// Enable the execution of
// pre-standby scripts when VMware tools is installed. Default: `true`.
func (r *VirtualMachine) RunToolsScriptsBeforeGuestStandby() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["runToolsScriptsBeforeGuestStandby"])
}

// Mode for sharing the SCSI bus. The modes are
// physicalSharing, virtualSharing, and noSharing. Default: `noSharing`.
func (r *VirtualMachine) ScsiBusSharing() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["scsiBusSharing"])
}

// The number of SCSI controllers that
// Terraform manages on this virtual machine. This directly affects the amount
// of disks you can add to the virtual machine and the maximum disk unit number.
// Note that lowering this value does not remove controllers. Default: `1`.
func (r *VirtualMachine) ScsiControllerCount() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["scsiControllerCount"])
}

// The type of SCSI bus this virtual machine will have.
// Can be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or
// pvscsi (VMware Paravirtual). Defualt: `pvscsi`.
func (r *VirtualMachine) ScsiType() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["scsiType"])
}

// The amount of time, in minutes, to wait
// for a graceful guest shutdown when making necessary updates to the virtual
// machine. If `force_power_off` is set to true, the VM will be force powered-off
// after this timeout, otherwise an error is returned. Default: 3 minutes.
func (r *VirtualMachine) ShutdownWaitTimeout() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["shutdownWaitTimeout"])
}

// The swap file placement policy for this
// virtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.
// Default: `inherit`.
func (r *VirtualMachine) SwapPlacementPolicy() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["swapPlacementPolicy"])
}

// Enable guest clock synchronization with
// the host. Requires VMware tools to be installed. Default: `false`.
func (r *VirtualMachine) SyncTimeWithHost() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["syncTimeWithHost"])
}

// The IDs of any tags to attach to this resource. See
// [here][docs-applying-tags] for a reference on how to apply tags.
func (r *VirtualMachine) Tags() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["tags"])
}

// The UUID of the virtual disk's VMDK file. This is used to track the
// virtual disk on the virtual machine.
func (r *VirtualMachine) Uuid() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["uuid"])
}

// Optional vApp configuration. The only sub-key available
// is `properties`, which is a key/value map of properties for virtual machines
// imported from OVF or OVA files. See Using vApp properties to supply OVF/OVA
// configuration for
// more details.
func (r *VirtualMachine) Vapp() *pulumi.Output {
	return r.s.State["vapp"]
}

// Computed value which is only valid for cloned virtual
// machines. A list of vApp transport methods supported by the source virtual
// machine or template.
func (r *VirtualMachine) VappTransports() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["vappTransports"])
}

// The state of VMware tools in the guest. This will
// determine the proper course of action for some device operations.
func (r *VirtualMachine) VmwareToolsStatus() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["vmwareToolsStatus"])
}

// The path of the virtual machine's configuration file in the VM's
// datastore.
func (r *VirtualMachine) VmxPath() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["vmxPath"])
}

// The amount of time, in minutes, to
// wait for an available guest IP address on this virtual machine. This should
// only be used if your version of VMware Tools does not allow the
// `wait_for_guest_net_timeout` waiter to be
// used. A value less than 1 disables the waiter. Default: 0.
func (r *VirtualMachine) WaitForGuestIpTimeout() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["waitForGuestIpTimeout"])
}

// Controls whether or not the guest
// network waiter waits for a routable address. When `false`, the waiter does
// not wait for a default gateway, nor are IP addresses checked against any
// discovered default gateways as part of its success criteria. This property is
// ignored if the `wait_for_guest_ip_timeout`
// waiter is used. Default: `true`.
func (r *VirtualMachine) WaitForGuestNetRoutable() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["waitForGuestNetRoutable"])
}

// The amount of time, in minutes, to
// wait for an available IP address on this virtual machine's NICs. Older
// versions of VMware Tools do not populate this property. In those cases, this
// waiter can be disabled and the
// `wait_for_guest_ip_timeout` waiter can be used
// instead. A value less than 1 disables the waiter. Default: 5 minutes.
func (r *VirtualMachine) WaitForGuestNetTimeout() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["waitForGuestNetTimeout"])
}

// Input properties used for looking up and filtering VirtualMachine resources.
type VirtualMachineState struct {
	// The guest name for the operating system
	// when `guest_id` is `other` or `other-64`.
	AlternateGuestName interface{}
	// A user-provided description of the virtual machine.
	// The default is no annotation.
	Annotation interface{}
	// The number of milliseconds to wait before starting
	// the boot sequence. The default is no delay.
	BootDelay interface{}
	// The number of milliseconds to wait before
	// retrying the boot sequence. This only valid if `boot_retry_enabled` is true.
	// Default: `10000` (10 seconds).
	BootRetryDelay interface{}
	// If set to true, a virtual machine that
	// fails to boot will try again after the delay defined in `boot_retry_delay`.
	// Default: `false`.
	BootRetryEnabled interface{}
	// A specification for a CDROM device on this virtual
	// machine. See CDROM options below.
	Cdrom interface{}
	// A unique identifier for a given version of the last
	// configuration applied, such the timestamp of the last update to the
	// configuration.
	ChangeVersion interface{}
	// When specified, the VM will be created as a clone of a
	// specified template. Optional customization options can be submitted as well.
	// See creating a virtual machine from a
	// template for more details.
	Clone interface{}
	// Allow CPUs to be added to this virtual
	// machine while it is running.
	CpuHotAddEnabled interface{}
	// Allow CPUs to be removed to this
	// virtual machine while it is running.
	CpuHotRemoveEnabled interface{}
	// The maximum amount of CPU (in MHz) that this virtual
	// machine can consume, regardless of available resources. The default is no
	// limit.
	CpuLimit interface{}
	// Enable CPU performance
	// counters on this virtual machine. Default: `false`.
	CpuPerformanceCountersEnabled interface{}
	// The amount of CPU (in MHz) that this virtual
	// machine is guaranteed. The default is no reservation.
	CpuReservation interface{}
	// The number of CPU shares allocated to the
	// virtual machine when the `cpu_share_level` is `custom`.
	CpuShareCount interface{}
	// The allocation level for CPU resources. Can be
	// one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
	CpuShareLevel interface{}
	// Map of custom attribute ids to attribute
	// value strings to set for virtual machine. See
	// [here][docs-setting-custom-attributes] for a reference on how to set values
	// for custom attributes.
	CustomAttributes interface{}
	// The [managed object reference
	// ID][docs-about-morefs] of the datastore cluster ID to use. This setting
	// applies to entire virtual machine and implies that you wish to use Storage
	// DRS with this virtual machine. See the section on virtual machine
	// migration for details on changing this value.
	DatastoreClusterId interface{}
	// The datastore ID that the ISO is located in.
	// Requried for using a datastore ISO. Conflicts with `client_device`.
	DatastoreId interface{}
	// The IP address selected by Terraform to be used with
	// any [provisioners][tf-docs-provisioners] configured on this resource.
	// Whenever possible, this is the first IPv4 address that is reachable through
	// the default gateway configured on the machine, then the first reachable IPv6
	// address, and then the first general discovered address if neither exist. If
	// VMware tools is not running on the virtual machine, or if the VM is powered
	// off, this value will be blank.
	DefaultIpAddress interface{}
	// A specification for a virtual disk device on this virtual
	// machine. See disk options below.
	Disks interface{}
	// When the `firmware` type is set to is
	// `efi`, this enables EFI secure boot. Default: `false`.
	EfiSecureBootEnabled interface{}
	// Expose the UUIDs of attached virtual disks to
	// the virtual machine, allowing access to them in the guest. Default: `false`.
	EnableDiskUuid interface{}
	// Enable logging of virtual machine events to a
	// log file stored in the virtual machine directory. Default: `false`.
	EnableLogging interface{}
	// The EPT/RVI (hardware memory virtualization)
	// setting for this virtual machine. Can be one of `automatic`, `on`, or `off`.
	// Default: `automatic`.
	EptRviMode interface{}
	// Extra configuration data for this virtual
	// machine. Can be used to supply advanced parameters not normally in
	// configuration, such as data for cloud-config (under the guestinfo namespace).
	ExtraConfig interface{}
	// The firmware interface to use on the virtual machine.
	// Can be one of `bios` or `EFI`. Default: `bios`.
	Firmware interface{}
	// The path to the folder to put this virtual machine in,
	// relative to the datacenter that the resource pool is in.
	Folder interface{}
	// If a guest shutdown failed or timed out while
	// updating or destroying (see
	// `shutdown_wait_timeout`), force the power-off of
	// the virtual machine. Default: `true`.
	ForcePowerOff interface{}
	// The guest ID for the operating system type. For a
	// full list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.
	GuestId interface{}
	// The current list of IP addresses on this machine,
	// including the value of `default_ip_address`. If VMware tools is not running
	// on the virtual machine, or if the VM is powered off, this list will be empty.
	// * `moid`: The [managed object reference ID][docs-about-morefs] of the created
	// virtual machine.
	GuestIpAddresses interface{}
	// An optional [managed object reference
	// ID][docs-about-morefs] of a host to put this virtual machine on. See the
	// section on virtual machine migration for
	// details on changing this value. If a `host_system_id` is not supplied,
	// vSphere will select a host in the resource pool to place the virtual machine,
	// according to any defaults or DRS policies in place.
	HostSystemId interface{}
	// The (non-nested) hardware virtualization setting for
	// this virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:
	// `hvAuto`.
	HvMode interface{}
	// List of IP addresses to ignore while waiting
	// for an available IP address using either of the waiters. Any IP addresses in
	// this list will be ignored if they show up so that the waiter will continue to
	// wait for a real IP address. Default: [].
	IgnoredGuestIps interface{}
	// This is flagged if the virtual machine has been imported, or the
	// state has been migrated from a previous version of the resource. It
	// influences the behavior of the first post-import apply operation. See the
	// section on importing below.
	Imported interface{}
	// Controls the scheduling delay of the
	// virtual machine. Use a higher sensitivity for applications that require lower
	// latency, such as VOIP, media player applications, or applications that
	// require frequent access to mouse or keyboard devices. Can be one of `low`,
	// `normal`, `medium`, or `high`.
	LatencySensitivity interface{}
	// The size of the virtual machine's memory, in MB.
	// Default: `1024` (1 GB).
	Memory interface{}
	// Allow memory to be added to this
	// virtual machine while it is running.
	MemoryHotAddEnabled interface{}
	// The maximum amount of memory (in MB) that this
	// virtual machine can consume, regardless of available resources. The default
	// is no limit.
	MemoryLimit interface{}
	// The amount of memory (in MB) that this
	// virtual machine is guaranteed. The default is no reservation.
	MemoryReservation interface{}
	// The number of memory shares allocated to
	// the virtual machine when the `memory_share_level` is `custom`.
	MemoryShareCount interface{}
	// The allocation level for memory resources.
	// Can be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
	MemoryShareLevel interface{}
	// The amount of time, in minutes, to wait
	// for a virtual machine migration to complete before failing. Default: 10
	// minutes. Also see the section on virtual machine
	// migration.
	MigrateWaitTimeout interface{}
	// The machine object ID from VMWare
	Moid interface{}
	// An alias for both `label` and `path`, the latter when
	// using `attach`. Required if not using `label`.
	Name interface{}
	// Enable nested hardware virtualization on
	// this virtual machine, facilitating nested virtualization in the guest.
	// Default: `false`.
	NestedHvEnabled interface{}
	// A specification for a virtual NIC on this
	// virtual machine. See network interface options
	// below.
	NetworkInterfaces interface{}
	// The number of cores to distribute among
	// the CPUs in this virtual machine. If specified, the value supplied to
	// `num_cpus` must be evenly divisible by this value. Default: `1`.
	NumCoresPerSocket interface{}
	// The number of virtual processors to assign to this
	// virtual machine. Default: `1`.
	NumCpus interface{}
	// Value internal to Terraform used to determine if a
	// configuration set change requires a reboot. This value is only useful during
	// an update process and gets reset on refresh.
	RebootRequired interface{}
	// The [managed object reference
	// ID][docs-about-morefs] of the resource pool to put this virtual machine in.
	// See the section on virtual machine migration
	// for details on changing this value.
	ResourcePoolId interface{}
	// Enable the execution of
	// post-power-on scripts when VMware tools is installed. Default: `true`.
	RunToolsScriptsAfterPowerOn interface{}
	// Enable the execution of
	// post-resume scripts when VMware tools is installed. Default: `true`.
	RunToolsScriptsAfterResume interface{}
	// Enable the execution of
	// pre-reboot scripts when VMware tools is installed. Default: `false`.
	RunToolsScriptsBeforeGuestReboot interface{}
	// Enable the execution
	// of pre-shutdown scripts when VMware tools is installed. Default: `true`.
	RunToolsScriptsBeforeGuestShutdown interface{}
	// Enable the execution of
	// pre-standby scripts when VMware tools is installed. Default: `true`.
	RunToolsScriptsBeforeGuestStandby interface{}
	// Mode for sharing the SCSI bus. The modes are
	// physicalSharing, virtualSharing, and noSharing. Default: `noSharing`.
	ScsiBusSharing interface{}
	// The number of SCSI controllers that
	// Terraform manages on this virtual machine. This directly affects the amount
	// of disks you can add to the virtual machine and the maximum disk unit number.
	// Note that lowering this value does not remove controllers. Default: `1`.
	ScsiControllerCount interface{}
	// The type of SCSI bus this virtual machine will have.
	// Can be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or
	// pvscsi (VMware Paravirtual). Defualt: `pvscsi`.
	ScsiType interface{}
	// The amount of time, in minutes, to wait
	// for a graceful guest shutdown when making necessary updates to the virtual
	// machine. If `force_power_off` is set to true, the VM will be force powered-off
	// after this timeout, otherwise an error is returned. Default: 3 minutes.
	ShutdownWaitTimeout interface{}
	// The swap file placement policy for this
	// virtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.
	// Default: `inherit`.
	SwapPlacementPolicy interface{}
	// Enable guest clock synchronization with
	// the host. Requires VMware tools to be installed. Default: `false`.
	SyncTimeWithHost interface{}
	// The IDs of any tags to attach to this resource. See
	// [here][docs-applying-tags] for a reference on how to apply tags.
	Tags interface{}
	// The UUID of the virtual disk's VMDK file. This is used to track the
	// virtual disk on the virtual machine.
	Uuid interface{}
	// Optional vApp configuration. The only sub-key available
	// is `properties`, which is a key/value map of properties for virtual machines
	// imported from OVF or OVA files. See Using vApp properties to supply OVF/OVA
	// configuration for
	// more details.
	Vapp interface{}
	// Computed value which is only valid for cloned virtual
	// machines. A list of vApp transport methods supported by the source virtual
	// machine or template.
	VappTransports interface{}
	// The state of VMware tools in the guest. This will
	// determine the proper course of action for some device operations.
	VmwareToolsStatus interface{}
	// The path of the virtual machine's configuration file in the VM's
	// datastore.
	VmxPath interface{}
	// The amount of time, in minutes, to
	// wait for an available guest IP address on this virtual machine. This should
	// only be used if your version of VMware Tools does not allow the
	// `wait_for_guest_net_timeout` waiter to be
	// used. A value less than 1 disables the waiter. Default: 0.
	WaitForGuestIpTimeout interface{}
	// Controls whether or not the guest
	// network waiter waits for a routable address. When `false`, the waiter does
	// not wait for a default gateway, nor are IP addresses checked against any
	// discovered default gateways as part of its success criteria. This property is
	// ignored if the `wait_for_guest_ip_timeout`
	// waiter is used. Default: `true`.
	WaitForGuestNetRoutable interface{}
	// The amount of time, in minutes, to
	// wait for an available IP address on this virtual machine's NICs. Older
	// versions of VMware Tools do not populate this property. In those cases, this
	// waiter can be disabled and the
	// `wait_for_guest_ip_timeout` waiter can be used
	// instead. A value less than 1 disables the waiter. Default: 5 minutes.
	WaitForGuestNetTimeout interface{}
}

// The set of arguments for constructing a VirtualMachine resource.
type VirtualMachineArgs struct {
	// The guest name for the operating system
	// when `guest_id` is `other` or `other-64`.
	AlternateGuestName interface{}
	// A user-provided description of the virtual machine.
	// The default is no annotation.
	Annotation interface{}
	// The number of milliseconds to wait before starting
	// the boot sequence. The default is no delay.
	BootDelay interface{}
	// The number of milliseconds to wait before
	// retrying the boot sequence. This only valid if `boot_retry_enabled` is true.
	// Default: `10000` (10 seconds).
	BootRetryDelay interface{}
	// If set to true, a virtual machine that
	// fails to boot will try again after the delay defined in `boot_retry_delay`.
	// Default: `false`.
	BootRetryEnabled interface{}
	// A specification for a CDROM device on this virtual
	// machine. See CDROM options below.
	Cdrom interface{}
	// When specified, the VM will be created as a clone of a
	// specified template. Optional customization options can be submitted as well.
	// See creating a virtual machine from a
	// template for more details.
	Clone interface{}
	// Allow CPUs to be added to this virtual
	// machine while it is running.
	CpuHotAddEnabled interface{}
	// Allow CPUs to be removed to this
	// virtual machine while it is running.
	CpuHotRemoveEnabled interface{}
	// The maximum amount of CPU (in MHz) that this virtual
	// machine can consume, regardless of available resources. The default is no
	// limit.
	CpuLimit interface{}
	// Enable CPU performance
	// counters on this virtual machine. Default: `false`.
	CpuPerformanceCountersEnabled interface{}
	// The amount of CPU (in MHz) that this virtual
	// machine is guaranteed. The default is no reservation.
	CpuReservation interface{}
	// The number of CPU shares allocated to the
	// virtual machine when the `cpu_share_level` is `custom`.
	CpuShareCount interface{}
	// The allocation level for CPU resources. Can be
	// one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
	CpuShareLevel interface{}
	// Map of custom attribute ids to attribute
	// value strings to set for virtual machine. See
	// [here][docs-setting-custom-attributes] for a reference on how to set values
	// for custom attributes.
	CustomAttributes interface{}
	// The [managed object reference
	// ID][docs-about-morefs] of the datastore cluster ID to use. This setting
	// applies to entire virtual machine and implies that you wish to use Storage
	// DRS with this virtual machine. See the section on virtual machine
	// migration for details on changing this value.
	DatastoreClusterId interface{}
	// The datastore ID that the ISO is located in.
	// Requried for using a datastore ISO. Conflicts with `client_device`.
	DatastoreId interface{}
	// A specification for a virtual disk device on this virtual
	// machine. See disk options below.
	Disks interface{}
	// When the `firmware` type is set to is
	// `efi`, this enables EFI secure boot. Default: `false`.
	EfiSecureBootEnabled interface{}
	// Expose the UUIDs of attached virtual disks to
	// the virtual machine, allowing access to them in the guest. Default: `false`.
	EnableDiskUuid interface{}
	// Enable logging of virtual machine events to a
	// log file stored in the virtual machine directory. Default: `false`.
	EnableLogging interface{}
	// The EPT/RVI (hardware memory virtualization)
	// setting for this virtual machine. Can be one of `automatic`, `on`, or `off`.
	// Default: `automatic`.
	EptRviMode interface{}
	// Extra configuration data for this virtual
	// machine. Can be used to supply advanced parameters not normally in
	// configuration, such as data for cloud-config (under the guestinfo namespace).
	ExtraConfig interface{}
	// The firmware interface to use on the virtual machine.
	// Can be one of `bios` or `EFI`. Default: `bios`.
	Firmware interface{}
	// The path to the folder to put this virtual machine in,
	// relative to the datacenter that the resource pool is in.
	Folder interface{}
	// If a guest shutdown failed or timed out while
	// updating or destroying (see
	// `shutdown_wait_timeout`), force the power-off of
	// the virtual machine. Default: `true`.
	ForcePowerOff interface{}
	// The guest ID for the operating system type. For a
	// full list of possible values, see [here][vmware-docs-guest-ids]. Default: `other-64`.
	GuestId interface{}
	// An optional [managed object reference
	// ID][docs-about-morefs] of a host to put this virtual machine on. See the
	// section on virtual machine migration for
	// details on changing this value. If a `host_system_id` is not supplied,
	// vSphere will select a host in the resource pool to place the virtual machine,
	// according to any defaults or DRS policies in place.
	HostSystemId interface{}
	// The (non-nested) hardware virtualization setting for
	// this virtual machine. Can be one of `hvAuto`, `hvOn`, or `hvOff`. Default:
	// `hvAuto`.
	HvMode interface{}
	// List of IP addresses to ignore while waiting
	// for an available IP address using either of the waiters. Any IP addresses in
	// this list will be ignored if they show up so that the waiter will continue to
	// wait for a real IP address. Default: [].
	IgnoredGuestIps interface{}
	// Controls the scheduling delay of the
	// virtual machine. Use a higher sensitivity for applications that require lower
	// latency, such as VOIP, media player applications, or applications that
	// require frequent access to mouse or keyboard devices. Can be one of `low`,
	// `normal`, `medium`, or `high`.
	LatencySensitivity interface{}
	// The size of the virtual machine's memory, in MB.
	// Default: `1024` (1 GB).
	Memory interface{}
	// Allow memory to be added to this
	// virtual machine while it is running.
	MemoryHotAddEnabled interface{}
	// The maximum amount of memory (in MB) that this
	// virtual machine can consume, regardless of available resources. The default
	// is no limit.
	MemoryLimit interface{}
	// The amount of memory (in MB) that this
	// virtual machine is guaranteed. The default is no reservation.
	MemoryReservation interface{}
	// The number of memory shares allocated to
	// the virtual machine when the `memory_share_level` is `custom`.
	MemoryShareCount interface{}
	// The allocation level for memory resources.
	// Can be one of `high`, `low`, `normal`, or `custom`. Default: `custom`.
	MemoryShareLevel interface{}
	// The amount of time, in minutes, to wait
	// for a virtual machine migration to complete before failing. Default: 10
	// minutes. Also see the section on virtual machine
	// migration.
	MigrateWaitTimeout interface{}
	// An alias for both `label` and `path`, the latter when
	// using `attach`. Required if not using `label`.
	Name interface{}
	// Enable nested hardware virtualization on
	// this virtual machine, facilitating nested virtualization in the guest.
	// Default: `false`.
	NestedHvEnabled interface{}
	// A specification for a virtual NIC on this
	// virtual machine. See network interface options
	// below.
	NetworkInterfaces interface{}
	// The number of cores to distribute among
	// the CPUs in this virtual machine. If specified, the value supplied to
	// `num_cpus` must be evenly divisible by this value. Default: `1`.
	NumCoresPerSocket interface{}
	// The number of virtual processors to assign to this
	// virtual machine. Default: `1`.
	NumCpus interface{}
	// The [managed object reference
	// ID][docs-about-morefs] of the resource pool to put this virtual machine in.
	// See the section on virtual machine migration
	// for details on changing this value.
	ResourcePoolId interface{}
	// Enable the execution of
	// post-power-on scripts when VMware tools is installed. Default: `true`.
	RunToolsScriptsAfterPowerOn interface{}
	// Enable the execution of
	// post-resume scripts when VMware tools is installed. Default: `true`.
	RunToolsScriptsAfterResume interface{}
	// Enable the execution of
	// pre-reboot scripts when VMware tools is installed. Default: `false`.
	RunToolsScriptsBeforeGuestReboot interface{}
	// Enable the execution
	// of pre-shutdown scripts when VMware tools is installed. Default: `true`.
	RunToolsScriptsBeforeGuestShutdown interface{}
	// Enable the execution of
	// pre-standby scripts when VMware tools is installed. Default: `true`.
	RunToolsScriptsBeforeGuestStandby interface{}
	// Mode for sharing the SCSI bus. The modes are
	// physicalSharing, virtualSharing, and noSharing. Default: `noSharing`.
	ScsiBusSharing interface{}
	// The number of SCSI controllers that
	// Terraform manages on this virtual machine. This directly affects the amount
	// of disks you can add to the virtual machine and the maximum disk unit number.
	// Note that lowering this value does not remove controllers. Default: `1`.
	ScsiControllerCount interface{}
	// The type of SCSI bus this virtual machine will have.
	// Can be one of lsilogic (LSI Logic Parallel), lsilogic-sas (LSI Logic SAS) or
	// pvscsi (VMware Paravirtual). Defualt: `pvscsi`.
	ScsiType interface{}
	// The amount of time, in minutes, to wait
	// for a graceful guest shutdown when making necessary updates to the virtual
	// machine. If `force_power_off` is set to true, the VM will be force powered-off
	// after this timeout, otherwise an error is returned. Default: 3 minutes.
	ShutdownWaitTimeout interface{}
	// The swap file placement policy for this
	// virtual machine. Can be one of `inherit`, `hostLocal`, or `vmDirectory`.
	// Default: `inherit`.
	SwapPlacementPolicy interface{}
	// Enable guest clock synchronization with
	// the host. Requires VMware tools to be installed. Default: `false`.
	SyncTimeWithHost interface{}
	// The IDs of any tags to attach to this resource. See
	// [here][docs-applying-tags] for a reference on how to apply tags.
	Tags interface{}
	// Optional vApp configuration. The only sub-key available
	// is `properties`, which is a key/value map of properties for virtual machines
	// imported from OVF or OVA files. See Using vApp properties to supply OVF/OVA
	// configuration for
	// more details.
	Vapp interface{}
	// The amount of time, in minutes, to
	// wait for an available guest IP address on this virtual machine. This should
	// only be used if your version of VMware Tools does not allow the
	// `wait_for_guest_net_timeout` waiter to be
	// used. A value less than 1 disables the waiter. Default: 0.
	WaitForGuestIpTimeout interface{}
	// Controls whether or not the guest
	// network waiter waits for a routable address. When `false`, the waiter does
	// not wait for a default gateway, nor are IP addresses checked against any
	// discovered default gateways as part of its success criteria. This property is
	// ignored if the `wait_for_guest_ip_timeout`
	// waiter is used. Default: `true`.
	WaitForGuestNetRoutable interface{}
	// The amount of time, in minutes, to
	// wait for an available IP address on this virtual machine's NICs. Older
	// versions of VMware Tools do not populate this property. In those cases, this
	// waiter can be disabled and the
	// `wait_for_guest_ip_timeout` waiter can be used
	// instead. A value less than 1 disables the waiter. Default: 5 minutes.
	WaitForGuestNetTimeout interface{}
}
